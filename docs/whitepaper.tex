%%% LEXICON %%%
% Block: A literal block on the workspace (like a move block)
% Chain: A series of connected blocks.
% Program: All chains on the workspace.
% Workspace: The canvas where blocks are 

\documentclass[]{article}

\usepackage{amsmath, amssymb, xspace, mathalfa, algorithm, algpseudocode, hyperref, graphicx}
\hypersetup{colorlinks=True, linkcolor=blue}
\graphicspath{ {images/} }

\title{Voice Programming in Computer Science Education}

\begin{document}
\maketitle

\section{Introduction}

\subsection{What is the goal of the project? What problem does it solve?}

\subsection{Who is meant to benefit?}

\subsection{What are the results or outcome of the project?}


\section{HCI Principles}

\subsection{What HCI principles were kept in mind in the design of our system?}

\subsection{How did those HCI principles influence our design decisions?}


\section{Blockly}

\subsection{What is the Blockly environment?}

\subsection{What is the goal of the Blockly project?}

\subsection{How are blocks arranged horizontally? What language do we use to describe this?}

\subsection{How are blocks arranged vertically? What language do we use to describe this?}

\subsection{Is just one chain of blocks allowed or several?}

\subsection{If several, how are they executed?}

\subsection{How does the user typically interact with Blockly?}

\subsubsection{What's the medium (hint: mouse)?}

\subsubsection{What actions are available?}

\subsubsection{How can we group them into categories?}

\subsubsection{How does moving blocks work?}

\subsubsection{How does deleting blocks work?}

\subsubsection{How does connecting blocks work?}

\subsubsection{How does separating blocks work?}


\section{Turtle}

\subsection{What is the turtle game?}

\subsection{What set of blocks are available to complete the game?}

\subsection{What do these blocks do?}

\subsection{Why is the game divided into levels?}

\subsection{How do the levels serve to teach different programming concepts?}


\section{Speech}

\subsection{Why did we decide to model speech using a} % This subsection heading might be incomplete?

\subsection{What choices did we make as we designed that grammar?}

\subsection{What commands are available in that grammar?}

\subsection{How do the user interface commands described earlier map to the commands in the grammar?  }


\section{Speech recognition}

\subsection{How do we perform the speech recognition? What do we use?}

\subsection{What tradeoffs are there in our decision by comparison to alternatives? What was gained and what lost?}

\clearpage

\section{Suggestions}

\subsection{Why do we give suggestions to the user? What HCI principle is behind this?}

%\subsection{What is basis on which a speech suggestion is made? What circumstances trigger it?}
%\subsection{What are the limitations of the current method and what future work might improve upon it?}
%\subsection{Show an example of the suggestions box and workspace before and after an operation}
We modify the suggestions list when we believe it could be useful for the user. For example, when there is a repeat block on the canvas, we suggest that the user connects a block inside of the repeat block, to make use of the repeat block. However, our current suggestions system is quite limited. It provides generic suggestions, not specific to the block IDs. For example, when an empty repeat block is on the canvas, we suggest that the user ``Connect block 2 inside block 1'' with these exact block IDs, regardless of what the block ID of the repeat block is. Finally, we provide an example in \hyperref[SuggestionsBeforeAndAfter]{Table \ref{SuggestionsBeforeAndAfter}} of the suggestions box with the corresponding workspace before and after adding the first block. \\
\begin{table}
	\caption{Example of suggestions before and after adding the first block to the workspace.}
	\label{SuggestionsBeforeAndAfter}
	\begin{tabular}{cccc}
		\hline
		when & workspace & suggestions \\\hline
		\\
		before & \includegraphics{suggestions_before_workspace.jpg} & \includegraphics{suggestions_before.jpg} \\\hline
		\\
		after & \includegraphics{suggestions_after_workspace.jpg} & \includegraphics{suggestions_after.jpg} \\\hline
	\end{tabular}
\end{table}

\section{Corrections}

%\subsection{Give an example of a common recognition error that falls out of the grammar}
%\subsection{What algorithm was used to correct recognition?}
%\subsection{If there are any parameters to be fit in this correction algorithm, how were they fit?}
As previously described, we use the webkitspeechrecognition speech API to capture user commands. However, the API has a hard time understanding commands from our grammar. We hypothesize that the API expects ordinary English, and as a result, phrases like "get a turn block" or "change 4 in block 3 to 5" are often recognized incorrectly by webkitspeechcrecognition. We developed a \hyperref[CorrectionAlgorithm]{novel algorithm} to correct incorrectly recognized phrases ("recognitions") to what we hope are the intended commands ("utterances"). The algorithm finds the command with minimal phoneme edit distance from the set of possible commands for a given workspace.
\begin{algorithm}
	\caption{Correction Algorithm}\label{CorrectionAlgorithm}
	\begin{algorithmic}[1]
		\Procedure{Correct}{recognition, workspace}
		\State $recognitionPhoneme \leftarrow stringToPhoneme(recognition)$
		\State $allPossibleCommands\leftarrow generateAllPossibleCommands(workspace) $
		\State $minimumEditDistance \leftarrow \infty$
		\State $minimumEditDistanceCommand = recognition$
		\For{$command$ in $allPossibleCommands$}
			\State $commandPhoneme \leftarrow stringToPhoneme(command)$
			\State $editDistance \leftarrow findMinimumEditDistance(recognitionPhoneme, commandPhoneme)$
			\If{$editDistance < minimumEditDistance$}
				\State $minimumEditDistanceCommand = command$
				\State $minimumEditDistance = editDistance$
			\EndIf
		\EndFor
		\State \Return{$minimumEditDistanceCommand$}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}\\
Furthermore, if the minimum edit-distance command is too far from the original recognition, we reject the correction and simply notify the user that we didn't understand their command. Our notion of "too far" is more concretely defined by a maximum modification factor which defines the the number of phoneme edits that can be made as a percentage of the number of phonemes in the recognition. As such, there is no fixed maximum number of edits, as this could give different performance for different string lengths. We determined the threshold in the following way.
\subsubsection{What statistical procedure was use?}
\subsubsection{What data was gathered?}
\subsubsection{What assumptions were made that could be considered weaknesses of the model?}
\subsection{Give an example of a common case that the corrections algorithm, as currently implemented, fails on}

\section{Layout}

%\subsection{How are commands interpreted visually?}
%\subsection{Where do new blocks go?}
%\subsection{How are blocks reordered when one is moved?}
%\subsection{What happens if the user runs out of space on the workspace?}
%\subsection{Describe the layout algorithm in pseudocode}
%\subsection{Show an example of the a before and after with the layout algorithm}
%\subsection{Are there any cases that currently give problems for the layout algorithm?}

As the user writes a program, certain locations on the workspace fill with blocks.
This presents a challenge: what should happen when blocks overlap with one another?
For our system to be practically useful, it must avoid introducing such visual impairments,
which may prevent the user from issuing commands (e.g. if they cannot see a block ID)
or which may introduce unnecessary cognitive load.

Blockly by default places new blocks at the top left of the workspace, even if the new block
will overlap an old block. Similarly, when Blockly connects one block to another, the resulting chain
might overlap another chain.

We devise simple layout algorithms for each case. To make this formal, we view
the workspace as a 2D plane.

% TODO(evanfredhernandez): Diagrams for these algorithms. And pseudocode?

\textbf{Adding Blocks} (1) Find the vertically lowest block on the workspace.
Let $y$ be the vertical coordinate of its lower left corner. (2) Place the new block
such that its top left corner is at $(20, y)$, that is, below the lowest block on the
workspace, 20 pixels right of the flyout.

\textbf{Moving Blocks} Suppose the user has just connected one block to another, and the
resulting chain now overlaps $n$ blocks. We repair the layout by moving the $n$ conflicting
blocks via the procedure below. For brevity, let $W$ and $H$ be the width and height of
the entire workspace, respectively, let $b$ be the block to be moved, and let
$w_b$ and $h_b$ be the width and height of $b$ and its children. Additionally define $m$
to be a small margin.
\begin{enumerate}
\item{Construct the set of candidate new locations: $$C = \{(x, y) = (rm, sm) : r, s \in \mathbb{Z}, x \le W, y \le H\}$$}
\item{For every $(x,y) \in C$ check if there is no block within the box bounded by the four points:
	$$(x,y), (x + w_b, y), (x, y + h_b), (x + w_b, y + h_b)$$
Let $(\hat{x}, \hat{y})$ be the first found satisfying that condition. If none is found, set $\hat{x} = \hat{y} = m$.
}
\item{Move $b$ so that its top left corner is located at $(\hat x, \hat y)$.}
\end{enumerate}
We choose $m = 20$ (pixels) because it is small enough to preserve space on the workspace,
and large enough to prevent Blockly from automatically connecting nearby blocks.

\section{Related Work}

\subsection{What is the related work in speech interfaces for programming?}

\subsection{What is the related work in speech interfaces for computer science education?}


\section{Future Work}

\end{document}
