\documentclass[]{article}

\usepackage{amsmath, amssymb, xspace, mathalfa}

\title{Voice Programming in Computer Science Education}

\begin{document}
\maketitle

\section{Introduction}

\subsection{What is the goal of the project? What problem does it solve?}

\subsection{Who is meant to benefit?}

\subsection{What are the results or outcome of the project?}


\section{HCI Principles}

\subsection{What HCI principles were kept in mind in the design of our system?}

\subsection{How did those HCI principles influence our design decisions?}


\section{Blockly}

\subsection{What is the Blockly environment?}

\subsection{What is the goal of the Blockly project?}

\subsection{How are blocks arranged horizontally? What language do we use to describe this?}

\subsection{How are blocks arranged vertically? What language do we use to describe this?}

\subsection{Is just one chain of blocks allowed or several?}

\subsection{If several, how are they executed?}

\subsection{How does the user typically interact with Blockly?}

\subsubsection{What's the medium (hint: mouse)?}

\subsubsection{What actions are available?}

\subsubsection{How can we group them into categories?}

\subsubsection{How does moving blocks work?}

\subsubsection{How does deleting blocks work?}

\subsubsection{How does connecting blocks work?}

\subsubsection{How does separating blocks work?}


\section{Turtle}

\subsection{What is the turtle game?}

\subsection{What set of blocks are available to complete the game?}

\subsection{What do these blocks do?}

\subsection{Why is the game divided into levels?}

\subsection{How do the levels serve to teach different programming concepts?}


\section{Speech}

\subsection{Why did we decide to model speech using a}

\subsection{What choices did we make as we designed that grammar?}

\subsection{What commands are available in that grammar?}

\subsection{How do the user interface commands described earlier map to the commands in the grammar?  }


\section{Speech recognition}

\subsection{How do we perform the speech recognition? What do we use?}

\subsection{What tradeoffs are there in our decision by comparison to alternatives? What was gained and what lost?}


\section{Suggestions}

\subsection{Why do we give suggestions to the user? What HCI principle is behind this?}

\subsection{What is basis on which a speech suggestion is made? What circumstances trigger it?}

\subsection{What are the limitations of the current method and what future work might improve upon it?}

\subsection{Show an example of the suggestions box and workspace before and after an operation}


\section{Corrections}

\subsection{Give an example of a common recognition error that falls out of the grammar}

\subsection{What algorithm was used to correct recognition?}

\subsection{If there are any parameters to be fit in this correction algorithm, how were they fit?}

\subsubsection{What statistical procedure was use?}

\subsubsection{What data was gathered?}

\subsubsection{What assumptions were made that could be considered weaknesses of the model?}

\subsection{Give an example of a common case that the corrections algorithm, as currently implemented, fails on}


\section{Layout}

%\subsection{How are commands interpreted visually?}
%\subsection{Where do new blocks go?}
%\subsection{How are blocks reordered when one is moved?}
%\subsection{What happens if the user runs out of space on the workspace?}
%\subsection{Describe the layout algorithm in pseudocode}
%\subsection{Show an example of the a before and after with the layout algorithm}
%\subsection{Are there any cases that currently give problems for the layout algorithm?}

As the user writes a program, certain locations on the workspace fill with blocks.
This presents a challenge: what should happen when blocks overlap with one another?
For our system to be practically useful, it must avoid introducing such visual impairments,
which may prevent the user from issuing commands (e.g. if they cannot see a block ID)
or which may introduce unnecessary cognitive load.

Blockly by default places new blocks at the top left of the workspace, even if the new block
will overlap an old block. Similarly, when Blockly connects one block to another, the resulting chain
might overlap another chain.

We devise simple layout algorithms for each case. To make this formal, we view
the workspace as a 2D plane.

% TODO(evanfredhernandez): Diagrams for these algorithms. And pseudocode?

\textbf{Adding Blocks} (1) Find the vertically lowest block on the workspace.
Let $y$ be the vertical coordinate of its lower left corner. (2) Place the new block
such that its top left corner is at $(20, y)$, that is, below the lowest block on the
workspace, 20 pixels right of the flyout.

\textbf{Moving Blocks} Suppose the user has just connected one block to another, and the
resulting chain now overlaps $n$ blocks. We repair the layout by moving the $n$ conflicting
blocks via the procedure below. For brevity, let $W$ and $H$ be the width and height of
the entire workspace, respectively, let $b$ be the block to be moved, and let
$w_b$ and $h_b$ be the width and height of $b$ and its children. Additionally define $m$
to be a small margin.
\begin{enumerate}
\item{Construct the set of candidate new locations: $$C = \{(x, y) = (rm, sm) : r, s \in \mathbb{Z}, x \le W, y \le H\}$$}
\item{For every $(x,y) \in C$ check if there is no block within the box bounded by the four points:
	$$(x,y), (x + w_b, y), (x, y + h_b), (x + w_b, y + h_b)$$
Let $(\hat{x}, \hat{y})$ be the first found satisfying that condition. If none is found, set $\hat{x} = \hat{y} = m$.
}
\item{Move $b$ so that its top left corner is located at $(\hat x, \hat y)$.}
\end{enumerate}
We choose $m = 20$ (pixels) because it is small enough to preserve space on the workspace,
and large enough to prevent Blockly from automatically connecting nearby blocks.

\section{Related Work}

\subsection{What is the related work in speech interfaces for programming?}

\subsection{What is the related work in speech interfaces for computer science education?}


\section{Future Work}

\end{document}